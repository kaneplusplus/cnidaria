// This file was generated by Rcpp::compileAttributes
// Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#include <Rcpp.h>

using namespace Rcpp;

#include "RAQRcppHeader.h"

// makeRAQ
XPtr<RAQType> makeRAQ(string ip, int port);
RcppExport SEXP cnidaria_makeRAQ(SEXP ipSEXP, SEXP portSEXP) {
BEGIN_RCPP
    SEXP __sexp_result;
    {
        Rcpp::RNGScope __rngScope;
        string ip = Rcpp::as<string >(ipSEXP);
        int port = Rcpp::as<int >(portSEXP);
        XPtr<RAQType> __result = makeRAQ(ip, port);
        PROTECT(__sexp_result = Rcpp::wrap(__result));
    }
    UNPROTECT(1);
    return __sexp_result;
END_RCPP
}
// addPop
bool addPop(XPtr<RAQType> raq, string key);
RcppExport SEXP cnidaria_addPop(SEXP raqSEXP, SEXP keySEXP) {
BEGIN_RCPP
    SEXP __sexp_result;
    {
        Rcpp::RNGScope __rngScope;
        XPtr<RAQType> raq = Rcpp::as<XPtr<RAQType> >(raqSEXP);
        string key = Rcpp::as<string >(keySEXP);
        bool __result = addPop(raq, key);
        PROTECT(__sexp_result = Rcpp::wrap(__result));
    }
    UNPROTECT(1);
    return __sexp_result;
END_RCPP
}
// popKeys
CharacterVector popKeys(XPtr<RAQType> raq);
RcppExport SEXP cnidaria_popKeys(SEXP raqSEXP) {
BEGIN_RCPP
    SEXP __sexp_result;
    {
        Rcpp::RNGScope __rngScope;
        XPtr<RAQType> raq = Rcpp::as<XPtr<RAQType> >(raqSEXP);
        CharacterVector __result = popKeys(raq);
        PROTECT(__sexp_result = Rcpp::wrap(__result));
    }
    UNPROTECT(1);
    return __sexp_result;
END_RCPP
}
// remPop
bool remPop(XPtr<RAQType> raq, string key);
RcppExport SEXP cnidaria_remPop(SEXP raqSEXP, SEXP keySEXP) {
BEGIN_RCPP
    SEXP __sexp_result;
    {
        Rcpp::RNGScope __rngScope;
        XPtr<RAQType> raq = Rcpp::as<XPtr<RAQType> >(raqSEXP);
        string key = Rcpp::as<string >(keySEXP);
        bool __result = remPop(raq, key);
        PROTECT(__sexp_result = Rcpp::wrap(__result));
    }
    UNPROTECT(1);
    return __sexp_result;
END_RCPP
}
// nextRAQMessage
List nextRAQMessage(XPtr<RAQType> raq, int timeout);
RcppExport SEXP cnidaria_nextRAQMessage(SEXP raqSEXP, SEXP timeoutSEXP) {
BEGIN_RCPP
    SEXP __sexp_result;
    {
        Rcpp::RNGScope __rngScope;
        XPtr<RAQType> raq = Rcpp::as<XPtr<RAQType> >(raqSEXP);
        int timeout = Rcpp::as<int >(timeoutSEXP);
        List __result = nextRAQMessage(raq, timeout);
        PROTECT(__sexp_result = Rcpp::wrap(__result));
    }
    UNPROTECT(1);
    return __sexp_result;
END_RCPP
}
// empty
bool empty(XPtr<RAQType> raq);
RcppExport SEXP cnidaria_empty(SEXP raqSEXP) {
BEGIN_RCPP
    SEXP __sexp_result;
    {
        Rcpp::RNGScope __rngScope;
        XPtr<RAQType> raq = Rcpp::as<XPtr<RAQType> >(raqSEXP);
        bool __result = empty(raq);
        PROTECT(__sexp_result = Rcpp::wrap(__result));
    }
    UNPROTECT(1);
    return __sexp_result;
END_RCPP
}
// makePopListener
XPtr<PopListener> makePopListener(string ip, int port);
RcppExport SEXP cnidaria_makePopListener(SEXP ipSEXP, SEXP portSEXP) {
BEGIN_RCPP
    SEXP __sexp_result;
    {
        Rcpp::RNGScope __rngScope;
        string ip = Rcpp::as<string >(ipSEXP);
        int port = Rcpp::as<int >(portSEXP);
        XPtr<PopListener> __result = makePopListener(ip, port);
        PROTECT(__sexp_result = Rcpp::wrap(__result));
    }
    UNPROTECT(1);
    return __sexp_result;
END_RCPP
}
// add
bool add(XPtr<PopListener> ppl, string key);
RcppExport SEXP cnidaria_add(SEXP pplSEXP, SEXP keySEXP) {
BEGIN_RCPP
    SEXP __sexp_result;
    {
        Rcpp::RNGScope __rngScope;
        XPtr<PopListener> ppl = Rcpp::as<XPtr<PopListener> >(pplSEXP);
        string key = Rcpp::as<string >(keySEXP);
        bool __result = add(ppl, key);
        PROTECT(__sexp_result = Rcpp::wrap(__result));
    }
    UNPROTECT(1);
    return __sexp_result;
END_RCPP
}
// remove
bool remove(XPtr<PopListener> ppl, string key);
RcppExport SEXP cnidaria_remove(SEXP pplSEXP, SEXP keySEXP) {
BEGIN_RCPP
    SEXP __sexp_result;
    {
        Rcpp::RNGScope __rngScope;
        XPtr<PopListener> ppl = Rcpp::as<XPtr<PopListener> >(pplSEXP);
        string key = Rcpp::as<string >(keySEXP);
        bool __result = remove(ppl, key);
        PROTECT(__sexp_result = Rcpp::wrap(__result));
    }
    UNPROTECT(1);
    return __sexp_result;
END_RCPP
}
// keys
CharacterVector keys(XPtr<PopListener> ppl);
RcppExport SEXP cnidaria_keys(SEXP pplSEXP) {
BEGIN_RCPP
    SEXP __sexp_result;
    {
        Rcpp::RNGScope __rngScope;
        XPtr<PopListener> ppl = Rcpp::as<XPtr<PopListener> >(pplSEXP);
        CharacterVector __result = keys(ppl);
        PROTECT(__sexp_result = Rcpp::wrap(__result));
    }
    UNPROTECT(1);
    return __sexp_result;
END_RCPP
}
// size
int size(XPtr<PopListener> ppl);
RcppExport SEXP cnidaria_size(SEXP pplSEXP) {
BEGIN_RCPP
    SEXP __sexp_result;
    {
        Rcpp::RNGScope __rngScope;
        XPtr<PopListener> ppl = Rcpp::as<XPtr<PopListener> >(pplSEXP);
        int __result = size(ppl);
        PROTECT(__sexp_result = Rcpp::wrap(__result));
    }
    UNPROTECT(1);
    return __sexp_result;
END_RCPP
}
// nextMessage
List nextMessage(XPtr<PopListener> ppl);
RcppExport SEXP cnidaria_nextMessage(SEXP pplSEXP) {
BEGIN_RCPP
    SEXP __sexp_result;
    {
        Rcpp::RNGScope __rngScope;
        XPtr<PopListener> ppl = Rcpp::as<XPtr<PopListener> >(pplSEXP);
        List __result = nextMessage(ppl);
        PROTECT(__sexp_result = Rcpp::wrap(__result));
    }
    UNPROTECT(1);
    return __sexp_result;
END_RCPP
}
